#!/usr/bin/perl

use strict;
use warnings;

use Config::PHPINI;
use XML::Simple;
use XML::LibXML;
use DBI;
use LWP::UserAgent;
use Getopt::Std;
use POSIX qw(strftime);
use Mail::Sendmail;
use Net::LDAP;
use Switch;
use MIME::Base64 qw/decode_base64/;
use Term::ANSIColor;

my %opts;
getopts('ftvcd',\%opts);

if (!@ARGV) {
    print "Usage: registry-harvester [OPTIONS] url\n";
    print "Options:\n";
    print "    -f    file mode, process url argument as a local file\n";
    print "    -t    test mode, don't actually create or update registry entries or send summary email\n";
    print "    -v    verbose, output information on what's happening\n";
    print "    -c    continue even if validation fails\n";
    print "    -d    print summary of registry to DIF matching (including duplicate registry entries)\n";
    exit;
}

my $log;
if ($opts{'t'}) {
    $log = *STDOUT;
}
else {
    my $logfile  = '/var/log/griidc/registry-harvester';
    open($log,'>>',$logfile) or die "cannot open log file $logfile: $!";
}

my $source = $ARGV[0];

writelog($log,"Registry Harvestor starting for: $source");

my $xml = XML::Simple->new(ForceArray => ['entry'], KeyAttr =>[]);

my ($doc,$data);

# retrieve XML file if remote and load into XML::LibXML and XML::Simple
if (defined $opts{'f'}) {
    $doc = XML::LibXML->new->parse_file($source);
    $data = $xml->XMLin($source);
}
else {
    my $ua = LWP::UserAgent->new;
    writelog($log,"retrieving: $source");
    my $response = $ua->get($source);
    if ($response->is_success) {
        writelog($log,"successfully retrieved: $source");
        $data = $xml->XMLin($response->decoded_content);
        $doc = XML::LibXML->load_xml(string => $response->decoded_content);
    }
    else {
        writelog($log,"could not retrieve: $source (" . $response->status_line . "), exiting",'error');
        exit;
    }
}

# validate XML against registry schema
my $xmlschema = XML::LibXML::Schema->new( location => '/var/www/schema/dataset_registry/dataset_registry.xsd' );
writelog($log,"validating: $source");
eval { $xmlschema->validate( $doc ); };
if ($@) {
    writelog($log,"validation failed for: $source",'error');
    unless ($opts{'c'}) {
        writelog($log,"Registry Harvestor finished for: $source");
        exit;
    }
}
else {
    writelog($log,"successfully validated: $source");
}

# process XML
writelog($log,"processing: $source");
print "\n" if $opts{'v'};

my $dbconf = Config::PHPINI->read('/etc/griidc/db.ini');

my %dbi_map = ( postgresql => 'Pg:dbname', mysql => 'mysql:database' );


my $griidc_dbh = DBI->connect('DBI:'.$dbi_map{$dbconf->{'GOMRI_RW'}->{'type'}}.'='.$dbconf->{'GOMRI_RW'}->{'dbname'},
                              $dbconf->{'GOMRI_RW'}->{'username'},
                              $dbconf->{'GOMRI_RW'}->{'password'})
                      or die "Couldn't connect to database: " . DBI->errstr;

$griidc_dbh->{'pg_enable_utf8'} = 1;

my $ris_dbh = DBI->connect('DBI:'.$dbi_map{$dbconf->{'RIS_RO'}->{'type'}}.'='.$dbconf->{'RIS_RO'}->{'dbname'},
                           $dbconf->{'RIS_RO'}->{'username'},
                           $dbconf->{'RIS_RO'}->{'password'})
                   or die "Couldn't connect to database: " . DBI->errstr;

my $ldap = Net::LDAP->new('triton.tamucc.edu') or die "$@";

my $mesg = $ldap->bind;

my @regCols = (
    'registry_id',
    'data_server_type',
    'data_source_pull',
    'doi',
    'availability_date',
    'access_status',
    'access_period',
    'access_period_start',
    'access_period_weekdays',
    'dataset_title',
    'dataset_abstract',
    'dataset_poc_name',
    'dataset_poc_email',
    'dataset_udi',
    'submittimestamp',
    'userid',
    'authentication',
    'generatedoi',
    'dataset_originator',
    'user_supplied_hash',
    'hash_algorithm',
    'dataset_filename',
    'url_data',
    'url_metadata'
);

my $count = 0;
my $update_count = 0;
my $create_count = 0;
my $duplicate_count = 0;
my $invalid_count = 0;
my $no_dif_count = 0;

my @update_udis;
my @create_udis;

my @update_regids;
my @create_regids;

my %seen;

my %DIFs;

# loop through all entries found in XML
for my $entry (@{$data->{'entry'}}) {
    my $reg = {};

    $reg->{'id'} = $entry->{'id'} if defined $entry->{'id'};

    # registration user
    if (defined $entry->{'registration_user'}->{'id'} and $entry->{'registration_user'}->{'id'}) {
        my $ris_id = $entry->{'registration_user'}->{'id'};

        $mesg = $ldap->search(
                                base => "ou=members,ou=people,dc=griidc,dc=org",
                              filter => "(employeeNumber=$ris_id)",
                               attrs => ['uid']
                             );

        $mesg->code && die $mesg->error;

        if ($mesg->entries) {
            my @entries = $mesg->entries;
            $reg->{'userid'} = $entries[0]->get_value('uid');
        }

    }

    my ($fs,$project_id,$task_id,$dif_seq,$originator_id,$point_of_contact_id);

    $reg->{'generatedoi'} = 0;

    # dataset information
    if (defined $entry->{'dataset'}) {
        if (defined $entry->{'dataset'}->{'source'}) {
            if (defined $entry->{'dataset'}->{'source'}->{'type'} and
                length $entry->{'dataset'}->{'source'}->{'type'}) {
                if ($entry->{'dataset'}->{'source'}->{'type'} eq 'gomri') {
                    if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}) {
                        if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'reference'} and
                            length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'reference'}) {
                            $fs = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'reference'};
                            $fs =~ s/0//;
                            if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}) {
                                if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'id'} and
                                    length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'id'}) {
                                    $project_id = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'id'};
                                }
                                if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}) {
                                    if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'id'} and
                                        length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'id'}) {
                                        $task_id = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'id'};
                                    }
                                    if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'dif'}->{'sequence'} and
                                        length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'dif'}->{'sequence'}) {
                                        $dif_seq = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'dif'}->{'sequence'};
                                    }
                                    if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'originator'}->{'id'} and
                                        length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'originator'}->{'id'}) {
                                        $originator_id = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'originator'}->{'id'};
                                    }
                                    if (defined $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'point_of_contact'}->{'id'} and
                                        length $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'point_of_contact'}->{'id'}) {
                                        $point_of_contact_id = $entry->{'dataset'}->{'source'}->{'funding_cycle'}->{'project'}->{'task'}->{'point_of_contact'}->{'id'};
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (defined $entry->{'dataset'}->{'title'} and length $entry->{'dataset'}->{'title'}) {
            $reg->{'dataset_title'} = $entry->{'dataset'}->{'title'};
        }
        if (defined $entry->{'dataset'}->{'abstract'} and length $entry->{'dataset'}->{'abstract'}) {
            $reg->{'dataset_abstract'} = $entry->{'dataset'}->{'abstract'};
        }
        if (defined $entry->{'dataset'}->{'filename'} and length $entry->{'dataset'}->{'filename'}) {
            $reg->{'dataset_filename'} = $entry->{'dataset'}->{'filename'};
        }
        if (defined $entry->{'dataset'}->{'doi'}) {
            if (defined $entry->{'dataset'}->{'doi'}->{'autogenerate'} and
                length $entry->{'dataset'}->{'doi'}->{'autogenerate'}) {
                $reg->{'generatedoi'} = 1;
            }
            elsif (length $entry->{'dataset'}->{'doi'}) {
                $reg->{'doi'} = $entry->{'dataset'}->{'doi'};
            }
        }
        if (defined $entry->{'dataset'}->{'hash'} and length $entry->{'dataset'}->{'hash'}->{'content'}) {
            if (defined $entry->{'dataset'}->{'hash'}->{'algorithm'} and
                length $entry->{'dataset'}->{'hash'}->{'algorithm'} and 
                defined $entry->{'dataset'}->{'hash'}->{'representation'} and
                length $entry->{'dataset'}->{'hash'}->{'representation'}) {
                $reg->{'hash_algorithm'} = $entry->{'dataset'}->{'hash'}->{'algorithm'};
                my $hash = '';
                switch ($entry->{'dataset'}->{'hash'}->{'representation'}) {
                    case 'base64' {
                        $hash = unpack('H*',decode_base64($entry->{'dataset'}->{'hash'}->{'content'}));
                    }
                    case 'octal' {  
                        my $octal = $entry->{'dataset'}->{'hash'}->{'content'};
                        my $i;
                        for ($i=length($octal)-4; $i>=0; $i-=4) {
                            $hash = sprintf('%x%s',oct(substr($octal,$i,4)),$hash);
                        }
                        if ($i < 0 and $i > -4) {
                            $hash = sprintf('%x%s',oct(substr($octal,0,4+$i)),$hash);
                        }
                    }
                    else {
                        $hash = lc($entry->{'dataset'}->{'hash'}->{'content'});
                    }
                }
                $reg->{'user_supplied_hash'} = $hash;
            }
        }
    }

    $reg->{'dataset_udi'} = sprintf("%s.x%03d.%03d:%04d",$fs,$project_id,$task_id,$dif_seq);

    # print information if verbose flag is set
    if ($opts{'v'}) {
        print "Processing entry for: $reg->{dataset_udi}\n";
        print "Title: $reg->{dataset_title}\n";
    }

    my $SQL = 'SELECT People_LastName, People_FirstName, People_Email FROM People WHERE People_ID = ?;';

    # look up dataset originator
    my $sth = $ris_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $ris_dbh->errstr;
    $sth->execute($originator_id);
    unless ($sth->rows) {
        writelog($log,"Invalid originator ID: $originator_id in entry for $reg->{dataset_udi}, skipping",'error');
        $invalid_count++;
        print "\n" if $opts{'v'};
        next;
    }
    my $ref = $sth->fetchrow_hashref();
    $reg->{'dataset_originator'} = "$ref->{People_LastName}, $ref->{People_FirstName}";
    $sth->finish();

    # look up dataset point of contact
    $sth = $ris_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $ris_dbh->errstr;
    $sth->execute($point_of_contact_id);
    unless ($sth->rows) {
        writelog($log,"Invalid Point of Contact ID: $point_of_contact_id in entry for $reg->{dataset_udi}, skipping",'error');
        $invalid_count++;
        print "\n" if $opts{'v'};
        next;
    }
    $ref = $sth->fetchrow_hashref();
    $reg->{'dataset_poc_name'} = "$ref->{People_LastName}, $ref->{People_FirstName}";
    $reg->{'dataset_poc_email'} = $ref->{'People_Email'};
    $sth->finish();

    # set access control
    if (defined $entry->{'access_control'}->{'restricted'} and length $entry->{'access_control'}->{'restricted'}) {
        if ($entry->{'access_control'}->{'restricted'} eq 'true') {
            $reg->{'access_status'} = 'Restricted';
            #TODO: need to add authorized_users
        }
        else {
            $reg->{'access_status'} = 'None';
        }
    }

    # set transport
    if (defined $entry->{'transport'}) {
        if (defined $entry->{'transport'}->{'method'} and length $entry->{'transport'}->{'method'}) {
            $reg->{'data_server_type'} = $entry->{'transport'}->{'method'};
        }
        if (defined $entry->{'transport'}->{'pull'} and length $entry->{'transport'}->{'pull'}) {
            $reg->{'data_source_pull'} = $entry->{'transport'}->{'pull'} eq 'true' ? 1 : 0;
        }
        if (defined $entry->{'transport'}->{'data_url'} and length $entry->{'transport'}->{'data_url'}) {
            $reg->{'url_data'} = $entry->{'transport'}->{'data_url'};
        }
        if (defined $entry->{'transport'}->{'metadata_url'} and length $entry->{'transport'}->{'metadata_url'}) {
            $reg->{'url_metadata'} = $entry->{'transport'}->{'metadata_url'};
        }
        #TODO: need to add pull times
    }

    # set timestamp
    $reg->{'submittimestamp'} = strftime '%Y-%m-%dT%H:%M:%S', localtime;

    for my $col (@regCols) { $reg->{$col} = undef if ref $reg->{$col}; }

    $count++;

    # make sure we have an approved DIF
    $SQL = 'SELECT dataset_uid,title FROM datasets WHERE dataset_udi = ? AND status = 2;';
    $sth = $griidc_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $griidc_dbh->errstr;
    $sth->execute($reg->{'dataset_udi'});
    my $dif_found = $sth->rows;
    my $dif = $sth->fetchrow_hashref();
    $sth->finish;

    unless ($dif_found) {
        writelog($log,"No approved DIF found for $reg->{dataset_udi}, skipping",'error');
        $no_dif_count++;
        print "\n" if $opts{'v'};
        next;
    }

    if ($opts{'v'}) {
        print "DIF found for $reg->{dataset_udi}\n";
        print "DIF title: $dif->{title}\n";
    }

    $DIFs{$reg->{'dataset_udi'}}->{'title'} = $dif->{'title'};
    push(@{$DIFs{$reg->{'dataset_udi'}}->{'registries'}},$reg);

    # skip duplicate entries for the same dataset
    if ($seen{$reg->{'dataset_udi'}}) {
        writelog($log,"Duplicate entry for $reg->{dataset_udi}, skipping",'error');
        $duplicate_count++;
        print "\n" if $opts{'v'};
        next;
    }
    $seen{$reg->{'dataset_udi'}} = 1;

    # check for existing registration
    $SQL = 'SELECT * FROM registry WHERE registry_id LIKE ? ORDER BY registry_id DESC;';
    $sth = $griidc_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $griidc_dbh->errstr;
    $sth->execute("$reg->{dataset_udi}.%");
    my $found = $sth->rows;

    if ($found) {
        if ($opts{'v'}) {
            print "Found existing registration for: $reg->{dataset_udi}\n";
        }
        # there is an existing registration
        # get existing values from DB
        my $ref = $sth->fetchrow_hashref();
        $sth->finish();

        # find updates
        my %updates;
        for my $col (@regCols) {
            next if $col eq 'registry_id' or $col eq 'submittimestamp';

            $ref->{$col} =~ s/[\r]//g if $ref->{$col};
            $reg->{$col} =~ s/[\r]//g if $reg->{$col};
            if (not defined $reg->{$col} and defined$ref->{$col} or
                defined $reg->{$col} and not defined$ref->{$col} or
                defined $reg->{$col} and defined$ref->{$col} and
                $reg->{$col} ne $ref->{$col}) {
                # save update
                $updates{$col} = $reg->{$col};
                if ($opts{'v'}) {
                    my $db_val = $ref->{$col};
                    $db_val = '<NULL>' if not defined $db_val;
                    my $xml_val = $reg->{$col};
                    $xml_val = '<NULL>' if not defined $xml_val;
                    print "     $col (db): |$db_val|\n";
                    print "    $col (xml): |$xml_val|\n";
                }
            }
        }

        # if there are updates
        if (%updates) {
            print "Updates found for $reg->{dataset_udi}\n" if $opts{'v'};
            my $reg_seq;
            ($reg_seq) = $ref->{'registry_id'} =~ /\.(\d{3})$/;
            $reg_seq++;
            $reg->{'registry_id'} = sprintf('%s.%03d',$reg->{'dataset_udi'},$reg_seq);
            writelog($log,"Updating registry entry for: $reg->{dataset_udi} (Registry ID: $reg->{registry_id})",'action');
            # if we're not in test mode, update the database
            if (!$opts{'t'}) {
                my $SQL = 'INSERT INTO registry(' . join(',',@regCols) . ') VALUES (' . join(',',('?') x (@regCols)) . ");";
                my $sth2 = $griidc_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $griidc_dbh->errstr;
                $sth2->execute(map { $reg->{$_} } @regCols[0..(@regCols-1)]) or die "Couldn't execute statement: " . $sth2->errstr;
                $sth2->finish();
            }
            push(@update_regids,$reg->{'registry_id'});
            $update_count++;
        }
        elsif ($opts{'v'}) {
            print "No updates detected for $reg->{dataset_udi}\n";
        }
        # if nothing has changed, do nothing
    }
    else {
        print "New registration: $reg->{dataset_udi}\n" if $opts{'v'};
        $reg->{'registry_id'} = "$reg->{dataset_udi}.001";
        # if there is no existing registration, create initial entry
        writelog($log,"Creating initial registry entry for: $reg->{dataset_udi}",'action');
        if (!$opts{'t'}) {
            my $SQL = 'INSERT INTO registry(' . join(',',@regCols) . ') VALUES (' . join(',',('?') x (@regCols)) . ");";
            my $sth2 = $griidc_dbh->prepare($SQL) or die "Couldn't prepare statement: " . $griidc_dbh->errstr;
            $sth2->execute(map { $reg->{$_} } @regCols[0..(@regCols-1)]) or die "Couldn't execute statement: " . $sth2->errstr;
            $sth2->finish();
        }
        push(@create_regids,$reg->{'registry_id'});
        $create_count++;
    }

    print "\n" if $opts{'v'};

}

$mesg = $ldap->unbind;

$griidc_dbh->disconnect;
$ris_dbh->disconnect;

my $summary = '';
if ($duplicate_count) {
    $summary .= "Skipped $duplicate_count duplicate registry entr" . ($duplicate_count == 1 ? 'y' : 'ies') . "\n\n";
}
if ($invalid_count) {
    $summary .= "Skipped $invalid_count registry entr" . ($invalid_count == 1 ? 'y' : 'ies') . " with invalid data\n\n";
}
if ($no_dif_count) {
    $summary .= "Skipped $no_dif_count registry entr" . ($no_dif_count == 1 ? 'y' : 'ies') . " with no approved DIF\n\n";
}
$summary .= "Processed $count registry entr" . ($count == 1 ? 'y' : 'ies') . "\n";
$summary .= "\nUpdated $update_count registry entr" . ($update_count == 1 ? 'y' : 'ies') . "\n";
for my $reg_id (@update_regids) {
    $summary .= "    $reg_id\n";
}
$summary .= "\nCreated $create_count registry entr" . ($create_count == 1 ? 'y' : 'ies') . "\n";
for my $reg_id (@create_regids) {
    $summary .= "    $reg_id\n";
}

# print summary if verbose flag is set
if ($opts{'v'}) {
    my $divider = '------------------------------';
    print colored("$divider\n$summary$divider\n",'cyan');
}

if (!$opts{'t'} and ($duplicate_count or $invalid_count or $update_count or $create_count)) {
    my $email = 'James.Davis@tamucc.edu';
    my %mail = ( To      => $email,
                 From    => 'registry-harvester@poseidon.tamucc.edu',
                 Subject => "Registry Harvester Summary for: $source",
                 Message => '',
                 'content-type' => 'text/plain; charset="iso-8859-1"'
               );
    $mail{'Message'} = "Registry Harvester Summary:\n\n$summary";
    sendmail(%mail) or die $Mail::Sendmail::error;
}

writelog($log,"Registry Harvestor finished for: $source");

if ($opts{'d'}) {
    print "\nDIF to Registry Summary\n";
    for my $udi (sort keys %DIFs) {
        print "\nDIF: $udi: $DIFs{$udi}->{title}\n";
        for my $reg (sort {$a->{'dataset_title'} cmp $b->{'dataset_title'}} @{$DIFs{$udi}->{'registries'}}) {
            print "  Registry Entry:\n";
            print "    ID: $reg->{id}\n" if defined  $reg->{id};
            print "    Title: $reg->{dataset_title}\n";
            print "    Filename: $reg->{dataset_filename}\n";
        }
    }
}

sub writelog {
    my ($log,$message,$type) = @_;
    my $ts = POSIX::strftime("%Y-%m-%d %H:%M:%S", localtime);
    if ($opts{'t'} or $opts{'v'}) {
        my $color = 'white';
        switch($type) {
            case 'error' { $color = 'red' }
            case 'action' { $color = 'green' }
        }
        print colored($message,$color),"\n";
    }
    print $log "[$ts] $message\n" unless $opts{'t'};
}
